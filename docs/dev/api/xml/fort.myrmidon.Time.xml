<?xml version='1.0' encoding='utf-8'?>
<class abstract="true" id="fort::myrmidon::Time" name="Time" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <brief>Time represent a point in Time</brief>
  <doc>Time represent a point in Time. Why re-implementing one of this
object and not using a `struct timeval` or a `std::chrono`. We are
dealing with long living experiment on heterogenous system. Under
this circunstances, we would like also to measure precise time
difference. For this purpose we could use the framegrabber
monolotic clock, which is timestamping every frame we acquired.

Well the issue is that we cannot solely rely on this clock, as we
may have several computers each with their own monolithic clock. Or
even with a single computer, every time we started the tracking we
must assume a new monotonic clock.

We could use the wall clock but this clock may be resetted any
time, and we would end up with issue where a time difference
between two consecutive frame could be negative.

Inspired from golang [time.Time](https://golang.org/pkg/time#Time)
we propose an Object that store both a Wall time, and a Monotonic
timestamp. But here we could have different monotonic timestamp. We
try, whenever its possible (both <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">Time</ref> have a monotonic time, and
they are issued from the same monotonic clock), use that value for
Time difference and Comparison. Otherwise the Wall clock value will
be used with the issue regarding the jitter or Wall clock reset.

Differentiaing Monotonic clock is done through <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::MonoclockID">MonoclockID</ref>
values. The 0 value is reserved for the <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::SYSTEM_MONOTONIC_CLOCK">SYSTEM_MONOTONIC_CLOCK</ref>
and which is used by <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Now">Now</ref>. When reading saved monotonic Timestamp
from the filesystem (as it is the case when reading data from
different &amp;lt;TrackingDataDirectory&amp;gt; ), care must be taken to assign
different <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::MonoclockID">MonoclockID</ref> for each of those reading. This class does
not enforce any mechanism. The only entry point to define the
<ref ref="fort::myrmidon::Time#fort::myrmidon::Time::MonoclockID">MonoclockID</ref> is through the utility function
<ref ref="fort::myrmidon::Time#fort::myrmidon::Time::FromTimestampAndMonotonic">FromTimestampAndMonotonic</ref>.

Every time are considered UTC.</doc>
  <variable id="fort::myrmidon::Time::SYSTEM_MONOTONIC_CLOCK" name="SYSTEM_MONOTONIC_CLOCK">
    <brief>The <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::MonoclockID">fort::myrmidon::Time::MonoclockID</ref> reserved for the current system</brief>
    <doc>`CLOCK_MONOTONIC`.</doc>
    <type name="MonoclockID" qualifier=" const" ref="fort::myrmidon::Time#fort::myrmidon::Time::MonoclockID" />
  </variable>
  <class name="Comparator" ref="fort::myrmidon::Time::Comparator#fort::myrmidon::Time::Comparator" />
  <class name="Overflow" ref="fort::myrmidon::Time::Overflow#fort::myrmidon::Time::Overflow">
    <brief>Time values can overflow when performing operation on them.</brief>
  </class>
  <typedef id="fort::myrmidon::Time::ConstPtr" name="ConstPtr">
    <brief>A const pointer to a Time</brief>
    <type name="std::shared_ptr&lt;const fort::myrmidon::Time&gt;" />
  </typedef>
  <typedef id="fort::myrmidon::Time::MonoclockID" name="MonoclockID">
    <brief>ID for a Monotonic Clock</brief>
    <type name="uint32_t" />
  </typedef>
  <typedef id="fort::myrmidon::Time::Ptr" name="Ptr">
    <brief>A pointer to a Time</brief>
    <type name="std::shared_ptr&lt;fort::myrmidon::Time&gt;" />
  </typedef>
  <typedef id="fort::myrmidon::Time::SortableKey" name="SortableKey">
    <brief>An object optimized for std::map or std::set</brief>
    <doc>SortableKey is an object constructed from current <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> to be
used as a computationnaly efficient key in std::map or
std::set. please note that this key has lost any monotonic
information.</doc>
    <type name="std::pair&lt;long, int&gt;" />
  </typedef>
  <constructor abstract="yes" id="fort::myrmidon::Time::Time" name="Time">
    <brief>Zero time constructor</brief>
  </constructor>
  <method abstract="yes" id="fort::myrmidon::Time::Add" name="Add">
    <brief>Adds a Duration to a Time</brief>
    <return>
      <type name="Time" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </return>
    <argument id="fort::myrmidon::Time::Add::d" name="d">
      <doc>the <ref ref="fort::myrmidon::Duration#fort::myrmidon::Duration">fort::myrmidon::Duration</ref> to add</doc>
      <type name="Duration" qualifier=" const &amp;" ref="fort::myrmidon::Duration#fort::myrmidon::Duration" />
    </argument>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::After" name="After">
    <brief>Reports if this time is after t</brief>
    <return>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="fort::myrmidon::Time::After::t" name="t">
      <doc>the <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> to test against</doc>
      <type name="Time" qualifier=" const &amp;" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </argument>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::Before" name="Before">
    <brief>Reports if this time is before t</brief>
    <return>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="fort::myrmidon::Time::Before::t" name="t">
      <doc>the <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> to test against</doc>
      <type name="Time" qualifier=" const &amp;" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </argument>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::DebugString" name="DebugString">
    <return>
      <type name="std::__cxx11::string" />
    </return>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::Equals" name="Equals">
    <brief>Reports if this time is the same than t</brief>
    <return>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="fort::myrmidon::Time::Equals::t" name="t">
      <doc>the <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> to test against</doc>
      <type name="Time" qualifier=" const &amp;" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </argument>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::FromTimestamp" name="FromTimestamp" static="yes">
    <brief>Creates a Time from a protobuf Timestamp</brief>
    <doc>Creates a <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> from a protobuf Timestamp. The <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> will not
have any monotonic clock value.</doc>
    <return>
      <type name="Time" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </return>
    <argument id="fort::myrmidon::Time::FromTimestamp::timestamp" name="timestamp">
      <doc>the `google.protobuf.Timestamp` message</doc>
      <type name="google::protobuf::Timestamp" qualifier=" const &amp;" />
    </argument>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::FromTimestampAndMonotonic" name="FromTimestampAndMonotonic" static="yes">
    <brief>Creates a Time from a protobuf Timestamp and an external Monotonic clock</brief>
    <doc>Creates a <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> from a protobuf Timestamp and an external
monotonic clock. The two values should correspond to the same
physical time. It is an helper function to create accurate
<ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> from data saved in `fort.hermes.FrameReadout` protobuf
messages that saves both a Wall time value and a framegrabber
timestamp for each frame. It is the caller responsability to
manage <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::FromTimestampAndMonotonic::monoID">monoID</ref> value for not mixing timestamp issued from
different clocks. Nothing prevent you to use
<ref ref="fort::myrmidon::Time#fort::myrmidon::Time::SYSTEM_MONOTONIC_CLOCK">fort::myrmidon::Time::SYSTEM_MONOTONIC_CLOCK</ref> for the <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::FromTimestampAndMonotonic::monoID">monoID</ref> value but the
behavior manipulating resulting time is undefined.</doc>
    <return>
      <type name="Time" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </return>
    <argument id="fort::myrmidon::Time::FromTimestampAndMonotonic::timestamp" name="timestamp">
      <doc>the `google.protobuf.Timestamp` message</doc>
      <type name="google::protobuf::Timestamp" qualifier=" const &amp;" />
    </argument>
    <argument id="fort::myrmidon::Time::FromTimestampAndMonotonic::nsecs" name="nsecs">
      <doc>the external monotonic value in nanoseconds</doc>
      <type name="uint64_t" />
    </argument>
    <argument id="fort::myrmidon::Time::FromTimestampAndMonotonic::monoID" name="monoID">
      <doc>the external monoID</doc>
      <type name="MonoclockID" ref="fort::myrmidon::Time#fort::myrmidon::Time::MonoclockID" />
    </argument>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::FromTimeT" name="FromTimeT" static="yes">
    <brief>Creates a Time from `time_t`</brief>
    <doc>Creates a <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> from `time_t`. The <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> will not have any
monotonic clock value.</doc>
    <return>
      <type name="Time" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </return>
    <argument id="fort::myrmidon::Time::FromTimeT::t" name="t">
      <doc>the time_t value</doc>
      <type name="time_t" />
    </argument>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::FromTimeval" name="FromTimeval" static="yes">
    <brief>Creates a Time from `struct timeval`</brief>
    <doc>Creates a <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> from `struct timeval`. The <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> will not
have any monotonic clock value.</doc>
    <return>
      <type name="Time" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </return>
    <argument id="fort::myrmidon::Time::FromTimeval::t" name="t">
      <doc>the `struct timeval`</doc>
      <type name="timeval" qualifier=" const &amp;" />
    </argument>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::HasMono" name="HasMono">
    <brief>Reports the presence of a monotonic time value</brief>
    <doc>Reports the presence of a monotonic time value. Only <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref>
issued by <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Now">fort::myrmidon::Time::Now</ref> or <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::FromTimestampAndMonotonic">fort::myrmidon::Time::FromTimestampAndMonotonic</ref> contains a
monotonic time value.</doc>
    <return>
      <type builtin="yes" name="bool" />
    </return>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::MonoFromSecNSec" name="MonoFromSecNSec" static="yes">
    <brief>Helpers to convert (sec,nsec) to nsec</brief>
    <doc>Helpers to convert (sec,nsec) to nsec. Throws <ref ref="fort::myrmidon::Time::Overflow#fort::myrmidon::Time::Overflow">fort::myrmidon::Time::Overflow</ref> on
overflow.</doc>
    <return>
      <type name="uint64_t" />
    </return>
    <argument id="fort::myrmidon::Time::MonoFromSecNSec::sec" name="sec">
      <doc>the amount of second</doc>
      <type name="uint64_t" />
    </argument>
    <argument id="fort::myrmidon::Time::MonoFromSecNSec::nsec" name="nsec">
      <doc>the amount of nanos</doc>
      <type name="uint64_t" />
    </argument>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::MonoID" name="MonoID">
    <brief>Returns the referred MonoclockID.</brief>
    <doc>Returns the referred <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::MonoclockID">fort::myrmidon::Time::MonoclockID</ref>. It throws std::exception if
this <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> has no monotonic clock value (see <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::HasMono">fort::myrmidon::Time::HasMono</ref>).</doc>
    <return>
      <type name="MonoclockID" ref="fort::myrmidon::Time#fort::myrmidon::Time::MonoclockID" />
    </return>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::MonotonicValue" name="MonotonicValue">
    <brief>Returns the monotonic value.</brief>
    <doc>Returns the monotonic value. It throws std::exception if
this <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> has no monotonic clock value (see <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::HasMono">fort::myrmidon::Time::HasMono</ref>).</doc>
    <return>
      <type name="uint64_t" />
    </return>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::Now" name="Now" static="yes">
    <brief>Gets the current Time</brief>
    <doc>Gets the current <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref>. This time will both have a wall and a
monotonic clock reading associated with the
<ref ref="fort::myrmidon::Time#fort::myrmidon::Time::SYSTEM_MONOTONIC_CLOCK">fort::myrmidon::Time::SYSTEM_MONOTONIC_CLOCK</ref>. Therefore such idioms:

```
Time start = Time::Now();
SomeFunction();
Duration ellapsed = Time::Now().Sub(start);
```

Will always return a positive Duration, even if the wall clock
has been reset between the two calls to <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Now">Now</ref></doc>
    <return>
      <type name="Time" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </return>
  </method>
  <method id="fort::myrmidon::Time::operator&lt;" name="operator&lt;">
    <brief>Less than operator</brief>
    <return>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="fort::myrmidon::Time::operator&lt;::other" name="other">
      <type name="Time" qualifier=" const &amp;" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </argument>
  </method>
  <method id="fort::myrmidon::Time::operator&lt;=" name="operator&lt;=">
    <brief>Less or equal operator</brief>
    <return>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="fort::myrmidon::Time::operator&lt;=::other" name="other">
      <type name="Time" qualifier=" const &amp;" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </argument>
  </method>
  <method id="fort::myrmidon::Time::operator==" name="operator==">
    <brief>Equal operator</brief>
    <return>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="fort::myrmidon::Time::operator==::other" name="other">
      <type name="Time" qualifier=" const &amp;" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </argument>
  </method>
  <method id="fort::myrmidon::Time::operator&gt;" name="operator&gt;">
    <brief>Greater than operator</brief>
    <return>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="fort::myrmidon::Time::operator&gt;::other" name="other">
      <type name="Time" qualifier=" const &amp;" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </argument>
  </method>
  <method id="fort::myrmidon::Time::operator&gt;=" name="operator&gt;=">
    <brief>Greate or equal operator</brief>
    <return>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="fort::myrmidon::Time::operator&gt;=::other" name="other">
      <type name="Time" qualifier=" const &amp;" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </argument>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::Parse" name="Parse" static="yes">
    <brief>Parses from RFC 3339 date string format.</brief>
    <doc>Parses from [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt)
date string format, i.e. string of the form
`1972-01-01T10:00:20.021-05:00`. It is merely a wrapper from
google::protobuf::time_util functions.</doc>
    <return>
      <type name="Time" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </return>
    <argument id="fort::myrmidon::Time::Parse::input" name="input">
      <doc>the string to parse</doc>
      <type name="std::__cxx11::string" qualifier=" const &amp;" />
    </argument>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::Round" name="Round">
    <brief>Rounds a Time to a Duration</brief>
    <doc>Rounds the <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> to the halp-rounded up <ref ref="fort::myrmidon::Duration#fort::myrmidon::Duration">fort::myrmidon::Duration</ref>
d. Currently only multiple of <ref ref="fort::myrmidon::Duration#fort::myrmidon::Duration::Second">fort::myrmidon::Duration::Second</ref> and power of
10 of <ref ref="fort::myrmidon::Duration#fort::myrmidon::Duration::Nanosecond">fort::myrmidon::Duration::Nanosecond</ref> which are smaller than a second
are supported.</doc>
    <return>
      <type name="Time" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </return>
    <argument id="fort::myrmidon::Time::Round::d" name="d">
      <doc>the <ref ref="fort::myrmidon::Duration#fort::myrmidon::Duration">fort::myrmidon::Duration</ref> to round to.</doc>
      <type name="Duration" qualifier=" const &amp;" ref="fort::myrmidon::Duration#fort::myrmidon::Duration" />
    </argument>
  </method>
  <method id="fort::myrmidon::Time::SortKey" name="SortKey">
    <brief>Returns the SortableKey representing this Time</brief>
    <return>
      <type name="SortableKey" ref="fort::myrmidon::Time#fort::myrmidon::Time::SortableKey" />
    </return>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::SortKey" name="SortKey" static="yes">
    <brief>Returns a SortableKey representing a Time pointer</brief>
    <doc>Returns a <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::SortableKey">fort::myrmidon::Time::SortableKey</ref> representing a pointer to a
<ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref>. Passing a nullptr to this function, will represent the
smallest possible key possible, which is then mathematically
equivalent to -∞ <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> (no result of Time::Parse can represent
this value).</doc>
    <return>
      <type name="SortableKey" ref="fort::myrmidon::Time#fort::myrmidon::Time::SortableKey" />
    </return>
    <argument id="fort::myrmidon::Time::SortKey::timePtr" name="timePtr">
      <type name="ConstPtr" qualifier=" const &amp;" ref="fort::myrmidon::Time#fort::myrmidon::Time::ConstPtr" />
    </argument>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::Sub" name="Sub">
    <brief>Computes time difference with another time</brief>
    <return>
      <type name="Duration" ref="fort::myrmidon::Duration#fort::myrmidon::Duration" />
    </return>
    <argument id="fort::myrmidon::Time::Sub::t" name="t">
      <doc>the <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> to substract to this one.</doc>
      <type name="Time" qualifier=" const &amp;" ref="fort::myrmidon::Time#fort::myrmidon::Time" />
    </argument>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::ToTimestamp" name="ToTimestamp">
    <brief>Converts to a protobuf Timestamp message</brief>
    <return>
      <type name="google::protobuf::Timestamp" />
    </return>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::ToTimestamp" name="ToTimestamp">
    <brief>In-place conversion to a protobuf Timestamp</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="fort::myrmidon::Time::ToTimestamp::timestamp" name="timestamp">
      <doc>the timestamp to modify to represent the <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref> and <ref ref="fort::myrmidon::Time#fort::myrmidon::Time::Time">fort::myrmidon::Time::Time</ref></doc>
      <type name="google::protobuf::Timestamp" qualifier="*" />
    </argument>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::ToTimeT" name="ToTimeT">
    <brief>Converts to a `time_t`</brief>
    <doc>Converts to a `time_t`. Please note that time_t have a maximal
resolution of a second.</doc>
    <return>
      <type name="time_t" />
    </return>
  </method>
  <method abstract="yes" id="fort::myrmidon::Time::ToTimeval" name="ToTimeval">
    <brief>Converts to a `struct timeval`</brief>
    <doc>Converts to a `struct timeval`. Please note that time_t have a maximal
resolution of a microsecond.</doc>
    <return>
      <type name="timeval" />
    </return>
  </method>
</class>
